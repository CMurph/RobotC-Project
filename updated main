#pragma config(Sensor, S1,     sonicSensor,    sensorSONAR)
#pragma config(Sensor, S2,     soundSensor,    sensorSoundDB)
#pragma config(Sensor, S3,     lightSensor,    sensorLightActive)
#pragma config(Sensor, S4,     touchSensor,    sensorTouch)

void turn_right();
void turn_left();
int forward();
void sweep();


int direction = 1;
/*
direction = 0 when robot facing up
direction = 1 when robot facing right
direction = 2 when robot facing down
direction = 3 when robot facing left
*/
int threshold = 59;
int row=3;
int col=0;


task main()
{
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;

while(blocks > 1 )
{
	sweep();
	
}

while(1==1)
{
	forward();
}



}//end main()






void turn_left()
{

//Make a 90 Degrees Right turn
motor[motorB] = 25;
motor[motorC] = -25;
//wait1Msec(750);
wait1Msec(760);

//Stop After turn Right executed
motor[motorB] = 0;
motor[motorB] = 0;
wait1Msec(200);

//calculating direction
direction =direction-1;
if (direction== -1) //required as RobotC can not get the mod of negative numbers
{
	direction = 3;
}
direction =(direction % 4);

}//end turn_left()



void turn_right()
{
//Make a 90 Degrees Right turn
motor[motorB] = -25;
motor[motorC] = 25;
//wait1Msec(750);
wait1Msec(760);
//Stop After turn Right executed
motor[motorB] = 0;
motor[motorC] = 0;
wait1Msec(200);

//calculating direction
direction= direction +1;
if (direction== -1) //required as RobotC can not get the mod of negative numbers
{
	direction = 3;
}
direction= (direction %4);
}//end turn_right()




int forward()
{
	//postions robot cannot go forward
	if(direction==0 && row==6)
	{
		turn_left();
		return 0;
	}
	if(direction==1 && col==8)
	{
		turn_left();
		return 0;
	}
	if(direction==2 && row==0)
	{
		turn_left();
		return 0;
	}
	if(direction==3 && col==0)
	{
		turn_left();
		return 0;
	}

	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;

	//go forward small amount to test for black
	nMotorEncoderTarget[motorB]=80;
	nMotorEncoderTarget[motorC]=80;

	motor[motorB]= 40;
	motor[motorC]= 40;

	while(nMotorRunState[motorB] != runStateIdle)
	{
	}
	motor[motorB]= 0;
	motor[motorC]= 0;
	wait1Msec(300);

	//if black detected return to postion
	if (SensorValue(lightSensor) < threshold)
	{
			//turn 180
			turn_right();
			turn_right();

			nMotorEncoderTarget[motorB]=80;
			nMotorEncoderTarget[motorC]=80;

			motor[motorB]= 40;
			motor[motorC]= 40;


			//stop when reach distance
			while(nMotorRunState[motorB] != runStateIdle)
			{
			}
			motor[motorB]= 0;
			motor[motorC]= 0;
			wait1Msec(300);

			//turn left
			turn_right();


	}//end of if


	else //if no black box detected
	{

			//remaining distance of one square
		nMotorEncoderTarget[motorB]=200;
		nMotorEncoderTarget[motorC]=200;

		motor[motorB]= 40;
		motor[motorC]= 40;


		while(nMotorRunState[motorB] != runStateIdle)
		{
		}
		motor[motorB]= 0;
		motor[motorC]= 0;
		wait1Msec(300);

		//calculation postion in grid
		if(direction==0) //if facing up
		{
			row=row+1;
		}

		if(direction==1)//if facing right
		{
			col=col+1;
		}

				if(direction==2)//if facing down
		{
			row=row-1;
		}

				if(direction==3) //if facing left
		{
			col=col-1;
		}
	}//end of else

	return 0;
}//end of forward()


void(sweep)
{
	
	turn_left();
	if (SensorValue(sonicSensor)>40))//must find value
	{
		block
	}
	
	turn_right();
	turn_right();
		if (SensorValue(sonicSensor)>40))//need value
	{
		//go to block
	}
	
	turn_left();
	forward();
}



	
